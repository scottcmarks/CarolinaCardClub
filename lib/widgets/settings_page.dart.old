// settings_page.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import 'package:awesome_datetime_picker/awesome_datetime_picker.dart';

import '../models/app_settings.dart';

import '../providers/app_settings_provider.dart';
import '../providers/time_provider.dart';


class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  // Local variables to hold temporary changes before applying
  late bool _localShowOnlyActiveSessions;
  late TimeOfDay? _sessionStartTime;
  late DateTime? _clockTime;
  late String _localPreferredTheme;
  late TextEditingController _remoteDatabaseUrlController; // For the new URL field

  @override
  void initState() {
    super.initState();
    // Initialize local variables from the current provider state
    final settings = Provider.of<AppSettingsProvider>(context, listen: false).currentSettings;
    _localShowOnlyActiveSessions = settings.showOnlyActiveSessions;
    _sessionStartTime = settings.sessionStartTime;
    _clockTime = Provider.of<TimeProvider>(context, listen: false).currentTime;
    _localPreferredTheme = settings.preferredTheme;
    _remoteDatabaseUrlController = TextEditingController(text: settings.remoteDatabaseUrl);
  }

  @override
  void dispose() {
    _remoteDatabaseUrlController.dispose();
    super.dispose();
  }

  Future<void> _selectSessionStartTime(BuildContext context) async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _sessionStartTime ?? TimeOfDay.fromDateTime(_clockTime!), // TODO: sessionStartTime as DateTime or epoch
      builder: (BuildContext context, Widget? child) {
        return Center(
          child: SizedBox(
            width: MediaQuery.of(context).size.width * 0.7,
            child: child,
          ),
        );
      },
    );
    if (picked != null && picked != _sessionStartTime) {
      setState(() {
        _sessionStartTime = picked;
      });
    }
  }

  void showAwesomeDateTimePickerBottomSheet(BuildContext context) {
    showModalBottomSheet<AwesomeDateTime>(
      context: context,
      // Set isScrollControlled to true to allow the bottom sheet to take up a larger portion of the screen.
      isScrollControlled: true,
      builder: (BuildContext context) {
        final DateTime defaultDateTime = _clockTime ?? DateTime.now();
        return Container(
          // Optionally, use padding to give some space around the picker
          padding: const EdgeInsets.only(top: 20),
          child: Column(
            mainAxisSize: MainAxisSize.min, // Make the Column wrap its content vertically.
            children: [
              Row(
                children:[
                  Expanded(
                    child: AwesomeDateTimePicker(
                      // The onChanged callback provides the selected AwesomeDateTime.
                      onChanged: (AwesomeDateTime dateTime) {
                        // Return the result to the caller of showModalBottomSheet.
                        Navigator.pop(context, dateTime);
                      },
                      // You can set minDate or maxDate to restrict the range.
                      minDateTime:
                        AwesomeDateTime(
                          date: AwesomeDate(
                            year:defaultDateTime.year,
                            month:defaultDateTime.month,
                            day:defaultDateTime.day,
                          ),
                          time: AwesomeTime(
                            hour: defaultDateTime.hour,
                            minute: defaultDateTime.minute,
                          ),
                        ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      },
    ).then((selectedAwesomeDateTime) {
      // This code runs after the bottom sheet is closed.
      if (selectedAwesomeDateTime != null) {
        // correctly convert the AwesomeDateTime to DateTime as shown in the previous response.
        _clockTime = DateTime(
          selectedAwesomeDateTime.date.year,
          selectedAwesomeDateTime.date.month,
          selectedAwesomeDateTime.date.day,
          selectedAwesomeDateTime.time.hour,
          selectedAwesomeDateTime.time.minute,
        );
        // You can call setState here if this is inside a StatefulWidget
        // to update the UI with the new time.
        setState(() {});
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final datePart = DateFormat.yMMMd();
    final timePart = DateFormat('HH:mm:ss');
    return Container(
      height: MediaQuery.of(context).size.height * 0.7, // Example height
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          const Text(
            'App Settings',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const Spacer(),
          SwitchListTile(
            title: const Text('Show only active sessions'),
            value: _localShowOnlyActiveSessions,
            onChanged: (bool newValue) {
              setState(() {
                _localShowOnlyActiveSessions = newValue;
              });
            },
          ),
          ListTile(
            title: const Text('Session Start Time'),
            subtitle: Text(
              _sessionStartTime?.format(context) ?? 'Not set',
            ),
            trailing: const Icon(Icons.access_time),
            onTap: () => _selectSessionStartTime(context),
          ),

          const Spacer(),
          TextButton(
            onPressed: () {
              showAwesomeDateTimePickerBottomSheet(context);
            },
            child: Text('Set Clock'),
          ),

          const Spacer(),
          ListTile(
            title: const Text('Preferred Theme'),
            trailing: DropdownButton<String>(
              value: _localPreferredTheme,
              onChanged: (String? newValue) {
                if (newValue != null) {
                  setState(() {
                    _localPreferredTheme = newValue;
                  });
                }
              },
              items: <String>['light', 'dark', 'system']
                  .map<DropdownMenuItem<String>>((String value) {
                return DropdownMenuItem<String>(
                  value: value,
                  child: Text(value),
                );
              }).toList(),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: TextField(
              controller: _remoteDatabaseUrlController,
              decoration: const InputDecoration(
                labelText: 'Remote Database URL',
                border: OutlineInputBorder(),
              ),
              onChanged: (newValue) {
                // No need to call setState here, as we're using a TextEditingController
                // The value will be read directly from the controller on save
              },
            ),
          ),
          const Spacer(),
          ElevatedButton(
            onPressed: () {
              // Get the provider instance to update it
              final appSettingsProvider = Provider.of<AppSettingsProvider>(context, listen: false);

              // Update the provider with the new settings
              appSettingsProvider.updateSettings(
                showOnlyActiveSessions: _localShowOnlyActiveSessions,
                sessionStartTime: _sessionStartTime,
                clockOffset: _clockTime!.difference(DateTime.now()),
                preferredTheme: _localPreferredTheme,
                remoteDatabaseUrl: _remoteDatabaseUrlController.text, // Add the new field
              );

              Navigator.pop(context); // Close the bottom sheet
            },
            child: const Text('Save Settings'),
          ),
        ],
      ),
    );
  }
}
