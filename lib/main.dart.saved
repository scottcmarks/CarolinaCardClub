// main.dart
import 'dart:async';
import 'dart:math';
import 'dart:io';
import 'dart:typed_data'; // Import for ByteData
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart';
import 'package:path/path.dart' as Path;
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart'; // Required for Provider
import 'package:sqflite/sqflite.dart';

import 'package:carolina_card_club/time_provider.dart';
import 'package:carolina_card_club/realtimeclock.dart';

import 'package:carolina_card_club/database/database_provider.dart';
import 'package:carolina_card_club/models/player_selection_item.dart';
import 'package:carolina_card_club/models/session_panel_item.dart';
import 'package:carolina_card_club/models/settings.dart';


import 'package:flutter_datetime_picker_plus/flutter_datetime_picker_plus.dart'
    as picker;




void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(
    ChangeNotifierProvider(
      create: (context) => DatabaseProvider(),
      child: ChangeNotifierProvider(
        create: (context) => TimeProvider(),
        child: const MyApp(),
      ),
    ),
  );
}
class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Carolina Card Club',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        textTheme: Theme.of(context).textTheme.copyWith(
              bodyLarge: const TextStyle(fontSize: 16.0),
              bodyMedium: const TextStyle(fontSize: 14.0),
            ),
      ),
      home: MainSplitViewPage(
          sessionStartTime: DateTime.now()
      ),
    );
  }
}

class MainSplitViewPage extends StatefulWidget {
  final DateTime sessionStartTime;

//  const MainSplitViewPage({Key? key}) : super(key: key);
  MainSplitViewPage({required this.sessionStartTime});

@override
  State<MainSplitViewPage> createState() => _MainSplitViewPageState();
}
DateTime setDateTimeToSpecificTime(DateTime inputDate, DateTime inputTime) {
  return DateTime(
    inputDate.year,
    inputDate.month,
    inputDate.day,
    inputTime.hour,
    inputTime.minute,
    inputTime.second,
    inputTime.millisecond,
    inputTime.microsecond,
  );
}

// Define default session startup time as a top-level "constant" DateTime object
final DateTime _defaultSessionStartTime = DateTime(2000, 1, 1, 19, 30); // Date part doesn't mater

DateTime setTimeToDefaultSessionStartTime(DateTime inputDateTime) {
  return setDateTimeToSpecificTime(inputDateTime, _defaultSessionStartTime);
}


class _MainSplitViewPageState extends State<MainSplitViewPage> {
  late Future<List<PlayerSelectionItem>> _playerListData;
  late Future<List<SessionPanelItem>> _sessionPanelListData;
  late DateTime _currentSessionStartTime;
  late bool _showOnlyActiveSessions = true;

  int? _selectedPlayerId;

  @override
  void initState() {
    super.initState();
    _playerListData = DatabaseProvider().fetchPlayerSelectionList();
    _sessionPanelListData = DatabaseProvider().fetchSessionPanelList();
    _currentSessionStartTime = widget.sessionStartTime;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _showStartTimeDialog(context);
    });
  }


  Future<void> x_showStartTimeDialog(BuildContext context) async {
    // Step 1: Show the date picker
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: DateTime.now(), // Sets the initial selected date to today
      helpText: 'Select Session Start Date',
      firstDate: DateTime(2020),   // The earliest date a user can select
      lastDate: DateTime(2100),    // The latest date a user can select
    );

    // If a date was picked, proceed to pick the time
    if (pickedDate != null) {
      // Step 2: Show the time picker
      final double screen_width = MediaQuery.of(context).size.width;
      final TimeOfDay? pickedTime = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.fromDateTime(_defaultSessionStartTime), // Default to picked day at 19:30
        helpText: 'Select Session Start Time',
        initialEntryMode: TimePickerEntryMode.input,
        builder: (BuildContext context, Widget? child) {
          return Center( // Center the dialog
            child: SizedBox(
              width: min(max(400, screen_width * 0.7), screen_width), // Limit width to 70% of screen width
              child: child,
            ),
          );
        },
      );

      // If both date and time were picked, combine them
      if (pickedTime != null) {
        final DateTime selectedDateTime = DateTime(
          pickedDate.year,
          pickedDate.month,
          pickedDate.day,
          pickedTime.hour,
          pickedTime.minute,
        );
        print('Selected Session Start date and time: $selectedDateTime');
        setState(() {
          _currentSessionStartTime = selectedDateTime;
        });
      }
    }
  }


  Future<void> _showStartTimeDialog(BuildContext context) async {
    DateTime selectedDateTime = _currentSessionStartTime;
    picker.DatePicker.showDateTimePicker(context,
        showTitleActions: true,
        onConfirm: (date) {
          selectedDateTime = date;
          print('Selected Session Start date and time: $selectedDateTime');
          setState(() {
            _currentSessionStartTime = selectedDateTime;
          });
        },
        currentTime: setTimeToDefaultSessionStartTime(selectedDateTime));
  }




  void _onPlayerSelected(int playerId) {
    setState(() {
      if (_selectedPlayerId == playerId) {
        _selectedPlayerId = null;
      } else {
        _selectedPlayerId = playerId;
      }
      _sessionPanelListData = DatabaseProvider().fetchSessionPanelList(playerId: _selectedPlayerId);
    });
  }


  void _onStopAllSessions() {
    // Implement your logic to stop the session here
    debugPrint("Stop All Sessions button pressed!");
    // You'd likely update all running sessions' stop time and refresh the UI
  }

  void _onSessionSelected(int sessionId) {
    debugPrint("Session $sessionId selected!");
    // Implement your logic for when a session is selected
  }

  @override
  Widget build(BuildContext context) {
    final String formattedSessionStartTime =
        DateFormat('HH:mm:ss').format(_currentSessionStartTime);

    // Listen to the DatabaseProvider
    final databaseProvider = Provider.of<DatabaseProvider>(context);

    // Generate session data based on the filter from the provider
    _showOnlyActiveSessions = databaseProvider.showingOnlyActiveSessions() ;


    return Scaffold(
      appBar: AppBar(
        title: Text('Carolina Card Club',
                           // style: GoogleFonts.lato( // Replace with your chosen Google Font
                           //   fontSize: 48,
                           //   fontWeight: FontWeight.w700,
                           //   foreground: Paint()
                           //     ..style = PaintingStyle.stroke
                           //     ..strokeWidth = 2 // Adjust the stroke width as needed
                           //     ..color = Color(0xFF4B9CD3), // Adjust the stroke color as needed
                           // )
                    style: const TextStyle( // Replace with your chosen Google Font
                                   fontSize: 48,
                                   color: Color(0xFF4B9CD3), // Adjust the stroke color as needed
                                 )
               ),
        centerTitle: true,
        actions: <Widget>[
          // Settings Icon
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              // Handle settings icon press
              debugPrint("Settings icon pressed!");
              showModalBottomSheet(
                context: context,
                useSafeArea: true, //If you are using a keyboard, then it is very important
                isScrollControlled: true,
                shape: const RoundedRectangleBorder(
                               borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
                             ),
                clipBehavior: Clip.antiAliasWithSaveLayer,
                builder: (context) => SettingsBottomSheet(),
              );
              setState((){
                _showOnlyActiveSessions = databaseProvider.showingOnlyActiveSessions();
              });
            },
          ),
          // Clock
          Padding(
            padding: const EdgeInsets.only(right: 16.0), // Add some padding
            child: RealtimeClock(), // Your clock widget
          ),
        ],
      ),
      body: Row(
        children: [


          // Left Pane: Player List
          Expanded(
            flex: 1,
            child: FutureBuilder<List<PlayerSelectionItem>>( // Specify the data model type
              future: _playerListData,
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                } else if (snapshot.hasError || snapshot.data == null || snapshot.data!.isEmpty) {
                  return const Center(child: Text('No players found.'));
                } else {
                  final data = snapshot.data!; // Now 'data' is List<PlayerSelectionItem>
                  return ListView.builder(
                    itemCount: data.length,
                    itemBuilder: (context, index) {
                      final PlayerSelectionItem item = data[index]; // Directly access the data model object

                      // No need to extract playerId, playerName, playerBalance from a map
                      final int playerId = item.playerId;
                      final String playerName = item.name;
                      final double playerBalance = item.balance; // Balance is now directly accessible

                      // Determine background color based on balance
                      Color? cardColor = _selectedPlayerId == playerId ? Colors.blue.shade100 : null;
                      if (playerBalance < 0) { //  Directly use the balance property
                        cardColor = Colors.red.shade100;
                      }

                      return Card(
                        margin: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                        color: cardColor,

                        child: MouseRegion(
                          onHover: (PointerHoverEvent event) {
                            if (event.synthesized == false && event.buttons == 0) {
                              if (HardwareKeyboard.instance.isShiftPressed) {
                                // Shift + hover detected
                              }
                            }
                          },
                          child: InkWell(
                            onTap: () {
                              if (HardwareKeyboard.instance.isShiftPressed) {
                                print("Shift + Left click!");
                              } else if (HardwareKeyboard.instance.isControlPressed) {
                                print("Ctrl/Cmd + Left click!");
                              } else if (HardwareKeyboard.instance.isAltPressed) {
                                print("Alt + Left click!");
                              } else {
                                print("Regular Left click!");
                              }
                              _onPlayerSelected(playerId); // Your original logic for player selection
                            },
                            onDoubleTap: () {
                              print("Double-tap!");
                            },
                            onLongPress: () {
                              print("Long press!");
                            },
                            onSecondaryTap: () {
                              print("Right click!");
                            },
                            child: ListTile(
                              title: Text(playerName),
                            ),
                          ),
                        )
                      );
                    },
                  );
                }
              },
            ),
          ),


          const VerticalDivider(width: 1),

          // Right Pane: Session List
          Expanded(
            flex: 2,
            child: Column( // Use a Column to stack the header and the list
              children: [
                // *** This is your "title bar" for the right pane ***
                Container(
                  padding: const EdgeInsets.all(12.0),
                  decoration: BoxDecoration(
                    color: Colors.grey[200], // A subtle background for the header
                    border: Border(bottom: BorderSide(color: Colors.grey[300]!)),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Session Start Time: $formattedSessionStartTime',
                        style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                      ),
                      ElevatedButton(
                        onPressed: _onStopAllSessions, // Call the stop all sessions method

                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.red,       // Background color of the button
                          foregroundColor: Colors.white,      // Text and icon color
                          elevation: 5,                       // Shadow elevation
                          shape: RoundedRectangleBorder(      // Custom shape
                            borderRadius: BorderRadius.circular(10),
                          ),
                          textStyle: const TextStyle(         // Style for the button's text
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                          padding: EdgeInsets.symmetric(horizontal: 20, vertical: 15), // Padding
                        ),
                        child: const Text('Stop All Sessions'),
                      ),
                    ],
                  ),
                ),
                // End of the right pane's "title bar"

                // The rest of your session list
                Expanded( // Wrap your FutureBuilder in Expanded to fill the remaining space
                  child: FutureBuilder<List<SessionPanelItem>>(
                    future: _sessionPanelListData,
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.waiting) {
                        return const Center(child: CircularProgressIndicator());
                      } else if (snapshot.hasError) {
                        return Center(child: Text('Error: ${snapshot.error}'));
                      } else if (snapshot.data == null || snapshot.data!.isEmpty) {
                        if (_selectedPlayerId == null) {
                          return const Center(child: Text('Nothing to see here.'));
                        } else {
                          return const Center(child: Text('No sessions found for selected player.'));
                        }
                      } else {
                        final data = snapshot.data!;  // now 'data' is List<<SessionPanelItem>>
                        return ListView.builder(
                          itemCount: data.length,
                          itemBuilder: (context, index) {
                            final SessionPanelItem item = data[index]; // Directly access the data model object

                            // No need to extract the name, etc. from a map
                            final String name = item.name;
                            final int? startEpoch = item.startEpoch;
                            final int? stopEpoch = item.stopEpoch;
                            final double? amount = item.amount;
                            final double? balance = item.balance;
                            final bool ongoing = stopEpoch == null ;

                            final String formattedStartTime = startEpoch != null
                                ? DateFormat('yyyy-MM-dd HH:mm').format(DateTime.fromMillisecondsSinceEpoch(startEpoch * 1000))
                                : 'N/A';
                            final String formattedStopTime = ! ongoing
                                ? DateFormat('HH:mm').format(DateTime.fromMillisecondsSinceEpoch(stopEpoch * 1000))
                                : 'Ongoing';
                            final String formattedAmount = amount != null ? '\$${amount.toStringAsFixed(2)}' : '\$0.00';
                            final String formattedBalance = balance != null ? '\$${balance.toStringAsFixed(2)}' : '\$0.00';

                            return Card(
                              margin: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                              child: MouseRegion(
                                onHover: (PointerHoverEvent event) {
                                  if (event.synthesized == false && event.buttons == 0) {
                                    if (HardwareKeyboard.instance.isShiftPressed) {
                                      // Shift + hover detected
                                      debugPrint("Shift + hover!");
                                    } else {
                                      // Hover detected.  Don't print, though -- too many! ;)
                                      // debugPrint("Hover!");
                                    }
                                  }
                                },
                                child: InkWell(
                                  onTap: () {
                                    if (HardwareKeyboard.instance.isShiftPressed) {
                                      // Shift + left click detected
                                      debugPrint("Shift + Left click!");
                                    } else if (HardwareKeyboard.instance.isControlPressed) {
                                      // Ctrl/Cmd + left click detected
                                      debugPrint("Ctrl/Cmd + Left click!");
                                    } else if (HardwareKeyboard.instance.isAltPressed) {
                                      // Alt + left click detected
                                      debugPrint("Alt + Left click!");
                                    } else {
                                      // Regular left click
                                      debugPrint("Regular Left click!");
                                    }
                                    _onSessionSelected(item.sessionId); // Your original logic for session selection
                                  },
                                  onSecondaryTap: () {
                                    // Right-click detected
                                    debugPrint("Right click!");
                                  },
                                  child: Padding(
                                    padding: const EdgeInsets.all(4),
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      children: [
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                          children: [
                                            Text(
                                              name,
                                              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                                            ),
                                            Text(
                                              'Balance: $formattedBalance',
                                              style: TextStyle(fontSize: 16.0, fontWeight: FontWeight.bold,
                                                       color:
                                                         ( ongoing
                                                           ? ( balance == null ? Colors.grey
                                                             : balance == 0.0 ? Colors.grey
                                                             : balance  < 0.0 ? Colors.red
                                                             :                  Colors.green
                                                         )
                                                       : Theme.of(context).scaffoldBackgroundColor
                                                       ),
                                                     ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 8),
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                          children: [
                                            Text(
                                              'Time Fee: $formattedAmount',
                                              style: TextStyle(fontSize: 18.0,
                                                       color: (ongoing ? Colors.green : Colors.black)
                                                     ),
                                            ),
                                            Text('$formattedStartTime - $formattedStopTime'),
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                              )
                            );
                          },
                        );
                      }
                    },
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
  }
}
